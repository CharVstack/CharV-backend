package qemu

import (
	"github.com/CharVstack/CharV-backend/entity"
	"github.com/CharVstack/CharV-backend/usecase/models"
	"github.com/google/uuid"
	"path/filepath"
	"reflect"
	"testing"
)

// dataAccess
type testVmDataAccess struct {}

func (t testVmDataAccess) Browse() ([]entity.Vm, error) {
	return []entity.Vm{}, nil
}

func (t testVmDataAccess) Add(vm entity.Vm) error {
	return nil
}

func (t testVmDataAccess) Read(id uuid.UUID) (entity.Vm, error) {
	return entity.Vm{}, nil
}

func (t testVmDataAccess) Edit(id uuid.UUID, vm entity.Vm) (entity.Vm, error) {
	return entity.Vm{}, nil
}

func (t testVmDataAccess) Delete(id uuid.UUID) error {
	return nil
}

// ID
type testID struct {}

func (t testID) GenID() (uuid.UUID, error) {
	id := uuid.Must(uuid.Parse("99999999-0000-4444-1111-112233445566"))
	return id, nil
}

// cmd
type testCommand struct {}

func (t testCommand) Run(name string, args []string) error  {
	return nil
}

func Test_qemuUseCase_Create(t *testing.T) {
	path, _ := filepath.Abs("../../../")
	id := uuid.Must(uuid.Parse("99999999-0000-4444-1111-112233445566"))

	type fields struct {
		dataAccess models.VmDataAccess
		id         models.ID
		cmd        models.Command
		conf       models.
	}
	type args struct {
		req entity.VmCore
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    entity.Vm
		wantErr bool
	}{
		{
			name: "PASS_01",
			fields: fields{
				dataAccess: testVmDataAccess{},
				id:         testID{},
				cmd:        testCommand{},
				conf:       models.ServiceConf{
					StoragePoolsPath: path + "testdata/resources/",
					SocksPath:        path + "testdata/resources/",
					MachinesPath:     path + "testdata/resources/",
				},
			},
			args: args{
				req: entity.VmCore{
					Cpu:    2,
					Memory: 2048,
					Name:   "test",
				},
			},
			want: entity.Vm{
				VmCore:         entity.VmCore{
					Cpu:    2,
					Memory: 2048,
					Name:   "test",
				},
				Id:             id,
				Devices:        entity.Devices{
					OS: entity.Disk{
						Device: entity.DiskDeviceCdrom,
						Name:   "ubuntu-20.04.5-live-api-amd64.iso",
						Pool:   "default",
						Type:   entity.DiskTypeIso,
					},
					Disk: []entity.Disk{
						{
							Device: entity.DiskDeviceDisk,
							Name:   id.String(),
							Pool:   "default",
							Type:   entity.DiskTypeQcow2,
						},
					},
				},
				Boot:           entity.BootDeviceDisk,
				Virtualization: entity.VirtualizationTypeKvm,
				Daemonize:      true,
			},
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			q := qemuUseCase{
				dataAccess: tt.fields.dataAccess,
				id:         tt.fields.id,
				cmd:        tt.fields.cmd,
				conf:       tt.fields.conf,
			}
			got, err := q.Create(tt.args.req)
			if (err != nil) != tt.wantErr {
				t.Errorf("Create() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Create() got = %v, want %v", got, tt.want)
			}
		})
	}
}
