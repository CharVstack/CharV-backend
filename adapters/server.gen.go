// Package adapters provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.2 DO NOT EDIT.
package adapters

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get a host
	// (GET /api/v1/host)
	GetApiV1Host(c *gin.Context)
	// Get all VMs list
	// (GET /api/v1/vms)
	GetApiV1Vms(c *gin.Context)
	// Create a new VM
	// (POST /api/v1/vms)
	PostApiV1Vms(c *gin.Context)
	// Get a VM
	// (GET /api/v1/vms/{vmId})
	GetApiV1VmsVmId(c *gin.Context, vmId openapi_types.UUID)
	// Update a VM
	// (PATCH /api/v1/vms/{vmId})
	PatchApiV1VmsVmId(c *gin.Context, vmId openapi_types.UUID)
	// Get Power State
	// (GET /api/v1/vms/{vmId}/power)
	GetApiV1VmsVmIdPower(c *gin.Context, vmId openapi_types.UUID)
	// Change Power Status
	// (POST /api/v1/vms/{vmId}/power)
	PostApiV1VmsVmIdPowerAction(c *gin.Context, vmId openapi_types.UUID, params PostApiV1VmsVmIdPowerActionParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetApiV1Host operation middleware
func (siw *ServerInterfaceWrapper) GetApiV1Host(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetApiV1Host(c)
}

// GetApiV1Vms operation middleware
func (siw *ServerInterfaceWrapper) GetApiV1Vms(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetApiV1Vms(c)
}

// PostApiV1Vms operation middleware
func (siw *ServerInterfaceWrapper) PostApiV1Vms(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.PostApiV1Vms(c)
}

// GetApiV1VmsVmId operation middleware
func (siw *ServerInterfaceWrapper) GetApiV1VmsVmId(c *gin.Context) {

	var err error

	// ------------- Path parameter "vmId" -------------
	var vmId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "vmId", c.Param("vmId"), &vmId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter vmId: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetApiV1VmsVmId(c, vmId)
}

// PatchApiV1VmsVmId operation middleware
func (siw *ServerInterfaceWrapper) PatchApiV1VmsVmId(c *gin.Context) {

	var err error

	// ------------- Path parameter "vmId" -------------
	var vmId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "vmId", c.Param("vmId"), &vmId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter vmId: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.PatchApiV1VmsVmId(c, vmId)
}

// GetApiV1VmsVmIdPower operation middleware
func (siw *ServerInterfaceWrapper) GetApiV1VmsVmIdPower(c *gin.Context) {

	var err error

	// ------------- Path parameter "vmId" -------------
	var vmId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "vmId", c.Param("vmId"), &vmId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter vmId: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetApiV1VmsVmIdPower(c, vmId)
}

// PostApiV1VmsVmIdPowerAction operation middleware
func (siw *ServerInterfaceWrapper) PostApiV1VmsVmIdPowerAction(c *gin.Context) {

	var err error

	// ------------- Path parameter "vmId" -------------
	var vmId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "vmId", c.Param("vmId"), &vmId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter vmId: %s", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PostApiV1VmsVmIdPowerActionParams

	// ------------- Optional query parameter "action" -------------

	err = runtime.BindQueryParameter("form", true, false, "action", c.Request.URL.Query(), &params.Action)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter action: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.PostApiV1VmsVmIdPowerAction(c, vmId, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router *gin.Engine, si ServerInterface) *gin.Engine {
	return RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router *gin.Engine, si ServerInterface, options GinServerOptions) *gin.Engine {

	errorHandler := options.ErrorHandler

	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/api/v1/host", wrapper.GetApiV1Host)

	router.GET(options.BaseURL+"/api/v1/vms", wrapper.GetApiV1Vms)

	router.POST(options.BaseURL+"/api/v1/vms", wrapper.PostApiV1Vms)

	router.GET(options.BaseURL+"/api/v1/vms/:vmId", wrapper.GetApiV1VmsVmId)

	router.PATCH(options.BaseURL+"/api/v1/vms/:vmId", wrapper.PatchApiV1VmsVmId)

	router.GET(options.BaseURL+"/api/v1/vms/:vmId/power", wrapper.GetApiV1VmsVmIdPower)

	router.POST(options.BaseURL+"/api/v1/vms/:vmId/power", wrapper.PostApiV1VmsVmIdPowerAction)

	return router
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"h59jKiIAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
