
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>storage: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/CharVstack/CharV-backend/pkg/host/storage/pool.go (72.2%)</option>
				
				<option value="file1">github.com/CharVstack/CharV-backend/pkg/host/storage/storage.go (0.0%)</option>
				
				<option value="file2">github.com/CharVstack/CharV-backend/pkg/qemu/disk.go (31.2%)</option>
				
				<option value="file3">github.com/CharVstack/CharV-backend/pkg/qemu/vm.go (22.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package storage

import (
        "encoding/json"
        "os"
        "path/filepath"

        "github.com/CharVstack/CharV-backend/domain/models"
)

func IsPoolExists(path string) bool <span class="cov0" title="0">{
        f, _ := os.Stat(path)
        return f.IsDir()
}</span>

func GetPoolFiles(storageDir string) ([]string, error) <span class="cov8" title="1">{
        entries, err := os.ReadDir(storageDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var files []string
        for _, entry := range entries </span><span class="cov8" title="1">{
                files = append(files, entry.Name())
        }</span>
        <span class="cov8" title="1">return files, nil</span>
}

func GetPoolInfo(file string, storageDir string) (models.StoragePool, error) <span class="cov8" title="1">{
        path, _ := filepath.Abs(filepath.Join(storageDir, file))
        bytes, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return models.StoragePool{}, err
        }</span>

        <span class="cov8" title="1">var storagePool models.StoragePool
        err = json.Unmarshal(bytes, &amp;storagePool)
        if err != nil </span><span class="cov0" title="0">{
                return models.StoragePool{}, err
        }</span>
        <span class="cov8" title="1">return storagePool, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package storage

import (
        "github.com/shirou/gopsutil/v3/disk"
)

func GetSize(path string) (size uint64, usedSize uint64, err error) <span class="cov0" title="0">{
        diskUsage, err := disk.Usage(path)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>
        <span class="cov0" title="0">return diskUsage.Total, diskUsage.Used, err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package qemu

import (
        "bytes"
        "errors"
        "os"
        "text/template"

        "github.com/CharVstack/CharV-backend/domain/models"
)

func createDisk(name string) (string, error) <span class="cov0" title="0">{
        name = "/var/lib/charVstack/images/" + name + "." + "qcow2"
        tmpl, err := template.New("create").Parse(`qemu-img create -f qcow2 {{.}} 16G`)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var buf bytes.Buffer
        err = tmpl.Execute(&amp;buf, name)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">cmd := buf.String()

        return name, run(cmd)</span>
}

func CheckFileType(filePath string) (models.DiskType, error) <span class="cov8" title="1">{
        buf, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if !bytes.Equal(buf[:4], []byte("QFI\xfb")) </span><span class="cov8" title="1">{
                return "", errors.New("Not QEMU QCOW Image (v3) ")
        }</span>

        <span class="cov8" title="1">return models.DiskTypeQcow2, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package qemu

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "text/template"
        "time"

        "github.com/digitalocean/go-qemu/qmp"

        "github.com/CharVstack/CharV-backend/domain/models"
        "github.com/CharVstack/CharV-backend/pkg/util"
        "github.com/google/uuid"
        "github.com/mattn/go-shellwords"
)

func install(opts InstallOpts, filePath string) (models.Vm, error) <span class="cov0" title="0">{
        tmpl, err := template.New("install").Parse(`qemu-system-x86_64 -accel kvm -daemonize -display none -name guest={{.Name}} -smp {{.VCpu}} -m {{.Memory}} -cdrom /var/lib/charVstack/iso/{{.Image}} -boot order=d -drive file=/var/lib/charVstack/images/{{.Disk}}.qcow2,format=qcow2 -drive file=/var/lib/charVstack/bios/bios.bin,format=raw,if=pflash,readonly=on -qmp unix:/{{.SocketPath}}/{{.Id}}.sock,server,nowait`)
        if err != nil </span><span class="cov0" title="0">{
                return models.Vm{}, err
        }</span>
        <span class="cov0" title="0">var buf bytes.Buffer
        err = tmpl.Execute(&amp;buf, opts)
        if err != nil </span><span class="cov0" title="0">{
                return models.Vm{}, err
        }</span>
        <span class="cov0" title="0">cmd := buf.String()
        fmt.Println(cmd)

        vm, err := getVmInfo(opts, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return models.Vm{}, err
        }</span>

        <span class="cov0" title="0">return vm, run(cmd)</span>
}

// CreateVm diskとVmをcharV-libの関数から作成する
func CreateVm(vmInfo models.PostApiV1VmsJSONRequestBody, socksPath string) (models.Vm, error) <span class="cov0" title="0">{
        id, err := uuid.NewRandom()
        if err != nil </span><span class="cov0" title="0">{
                return models.Vm{}, err
        }</span>

        <span class="cov0" title="0">toGetInfo := InstallOpts{
                Name:       vmInfo.Name,
                Memory:     vmInfo.Memory,
                VCpu:       vmInfo.Cpu,
                Image:      "ubuntu-20.04.5-live-server-amd64.iso",
                Disk:       vmInfo.Name + "Disk", // ToDo: 現在ストレージの複数作成機能がフロントエンドにないので１つを前提にしている
                Id:         id,
                SocketPath: socksPath,
        }

        name, err := createDisk(toGetInfo.Disk)
        if err != nil </span><span class="cov0" title="0">{
                return models.Vm{}, err
        }</span>

        <span class="cov0" title="0">var createVm models.Vm
        createVm, err = install(toGetInfo, name)
        if err != nil </span><span class="cov0" title="0">{
                return models.Vm{}, err
        }</span>

        <span class="cov0" title="0">return createVm, err</span>
}

func getAllVms(directoryPath string) ([]models.Vm, error) <span class="cov8" title="1">{
        var vmList []models.Vm
        dir, err := os.ReadDir(directoryPath)
        if err != nil </span><span class="cov0" title="0">{
                return []models.Vm{}, err
        }</span>

        <span class="cov8" title="1">for _, file := range dir </span><span class="cov8" title="1">{
                raw, err := os.ReadFile(directoryPath + file.Name())
                if err != nil </span><span class="cov0" title="0">{
                        return []models.Vm{}, err
                }</span>

                <span class="cov8" title="1">var vm models.Vm
                err = json.Unmarshal(raw, &amp;vm)
                if err != nil </span><span class="cov0" title="0">{
                        return []models.Vm{}, err
                }</span>

                <span class="cov8" title="1">vmList = append(vmList, vm)</span>

        }
        <span class="cov8" title="1">return vmList, err</span>
}

func getVmInfo(opts InstallOpts, filePath string) (vmInfo models.Vm, err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                return models.Vm{}, err
        }</span>

        <span class="cov0" title="0">var diskType models.DiskType
        diskType, err = CheckFileType(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return models.Vm{}, err
        }</span>

        <span class="cov0" title="0">vmInfo = models.Vm{
                Devices: models.Devices{
                        Disk: []models.Disk{
                                {
                                        Type:   diskType,
                                        Device: models.DiskDeviceDisk,
                                        Name:   opts.Disk,
                                        Pool:   "default", // ToDo: ストレージの選択機能がないので "default" で固定
                                },
                        },
                },
                Memory: opts.Memory,
                Metadata: models.Metadata{
                        ApiVersion: "v1",
                        Id:         opts.Id,
                },
                Name: opts.Name,
                Cpu:  opts.VCpu,
        }

        rawVmInfo, err := json.Marshal(vmInfo)
        if err != nil </span><span class="cov0" title="0">{
                return models.Vm{}, err
        }</span>

        <span class="cov0" title="0">createJSONPath := "/var/lib/charVstack/machines/"

        fileName := createJSONPath + vmInfo.Name + "-" + vmInfo.Metadata.Id.String() + ".json"

        createFile, err := os.Create(fileName)
        if err != nil </span><span class="cov0" title="0">{
                return models.Vm{}, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                err = createFile.Close()
        }</span>()

        <span class="cov0" title="0">_, err = createFile.Write(rawVmInfo)
        if err != nil </span><span class="cov0" title="0">{
                return models.Vm{}, err
        }</span>

        <span class="cov0" title="0">return vmInfo, nil</span>
}

func GetAllVmInfo() ([]models.Vm, error) <span class="cov0" title="0">{
        path := "/var/lib/charVstack/machines/"
        vms, err := getAllVms(path)
        if err != nil </span><span class="cov0" title="0">{
                return []models.Vm{}, err
        }</span>
        <span class="cov0" title="0">return vms, nil</span>
}

func run(cmd string) error <span class="cov0" title="0">{
        c, err := shellwords.Parse(cmd)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">switch len(c) </span>{
        case 0:<span class="cov0" title="0">
                return nil</span>
        case 1:<span class="cov0" title="0">
                err = exec.Command(c[0]).Run()</span>
        default:<span class="cov0" title="0">
                err = exec.Command(c[0], c[1:]...).Run()</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func parse(path string) (models.Vm, error) <span class="cov8" title="1">{
        var machine models.Vm
        abspath, err := filepath.Abs(path)
        raw, err := os.ReadFile(abspath)
        if err != nil </span><span class="cov0" title="0">{
                return models.Vm{}, err
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(raw, &amp;machine); err != nil </span><span class="cov0" title="0">{
                return models.Vm{}, err
        }</span>
        <span class="cov8" title="1">return machine, nil</span>
}

func GetVmPower(id uuid.UUID, path string) (models.VmPowerInfo, error) <span class="cov8" title="1">{
        // get all opened sockets
        sockFiles, err := os.ReadDir(path)
        if err != nil </span><span class="cov8" title="1">{
                return models.VmPowerInfo{}, err
        }</span>
        <span class="cov8" title="1">var socks []string
        for _, v := range sockFiles </span><span class="cov8" title="1">{
                socks = append(socks, v.Name()[:36])
        }</span>

        // try finding the target id
        <span class="cov8" title="1">i := util.SearchVmId(socks, id)
        if i != -1 </span><span class="cov8" title="1">{ // found
                return models.VmPowerInfo{
                        CleanPowerOff: true,
                        State:         "RUNNING",
                }, nil
        }</span>

        // not found
        <span class="cov8" title="1">return models.VmPowerInfo{
                CleanPowerOff: true,
                State:         "SHUTDOWN",
        }, nil</span>
}

func HandleChangeVmPower(id uuid.UUID, action models.PostApiV1VmsVmIdPowerActionParamsAction, sockPath string) error <span class="cov0" title="0">{
        switch action </span>{
        case "start":<span class="cov0" title="0">
                fmt.Println("start")
                return nil</span>
        case "shutdown":<span class="cov0" title="0">
                err := changeVmPower(&amp;id, &amp;sockPath, "system_powerdown")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case "reset":<span class="cov0" title="0">
                err := changeVmPower(&amp;id, &amp;sockPath, "system_reset")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case "reboot":<span class="cov0" title="0">
                fmt.Println("reboot")
                return nil</span>
        default:<span class="cov0" title="0">
                return errors.New("there is an error in the query parameter")</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func changeVmPower(id *uuid.UUID, sockPath *string, action models.PostApiV1VmsVmIdPowerActionParamsAction) error <span class="cov0" title="0">{
        file := *sockPath + "/" + id.String() + ".sock"

        sock, err := qmp.NewSocketMonitor("unix", file, 2*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sock.Connect()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer sock.Disconnect()

        cmd := []byte(`{ "execute": "` + action + `" }`)
        _, err = sock.Run(cmd)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cmd = []byte(`{ "execute": "quit" }`)
        _, err = sock.Run(cmd)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
